## 1) Theory

* 정의: 컬렉션(또는 연관 엔티티) 목록을 1번 쿼리로 가져온 뒤, 각 원소의 LAZY 연관을 접근할 때마다 추가 쿼리가 N번 더 발생하는 현상. 총 **1 + N** 쿼리.
* 발생 조건: `@ManyToOne/@OneToOne/@OneToMany`가 LAZY이고, 목록 조회 후 `item.getXxx()`로 연관을 순회 접근.
* 증상: 같은 형태의 `select ... where id=?`가 N번 반복. 성능이 O(N)로 악화.
* 해결 핵심: **한 번의 쿼리로 연관을 같이 로딩**하거나, **배치 로딩으로 N을 묶어 감소**.

## 2) Example code

```java
// 엔티티
@Entity class Todo {
  @ManyToOne(fetch = FetchType.LAZY) private User user;
}

// 문제되는 리포지토리
interface TodoRepository extends JpaRepository<Todo, Long> {
  Page<Todo> findAllByOrderByModifiedAtDesc(Pageable pageable); // N+1 가능
}

// 해결 1) EntityGraph
interface TodoRepository extends JpaRepository<Todo, Long> {
  @EntityGraph(attributePaths = "user")
  Page<Todo> findAllByOrderByModifiedAtDesc(Pageable pageable); // N+1 제거
}

// 해결 2) JPQL fetch join
@Query("""
  select t from Todo t
  join fetch t.user
  order by t.modifiedAt desc
""")
List<Todo> findAllWithUser();

// 해결 3) 배치 로딩(보완책)

# application.yml
spring:
  jpa:
    properties:
      hibernate.default_batch_fetch_size: 100
```

## 3) Execution and testing method

```yaml
SQL 로그 켜기
logging:
  level:
    org.hibernate.SQL: DEBUG
    org.hibernate.orm.jdbc.bind: TRACE
```

```bash
로그인 → 토큰
TOKEN=$(http --body POST :8080/auth/signin email=a@a.com password=Abcd1234 \
  | jq -r '.bearerToken' | sed -E 's/^Bearer //')

목록 조회
http GET :8080/todos page==0 size==10 Authorization:"Bearer $TOKEN"
```

* 수정 전: 로그에 `select todo...` 1회 + `select user... where id=?`가 항목 수만큼 반복.
* 수정 후(EntityGraph/fetch join): 콘텐츠 쿼리 1회(+페이지네이션이면 count 1회)로 끝나면 해결.
